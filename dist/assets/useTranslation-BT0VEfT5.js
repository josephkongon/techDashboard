import{r as g,I as _,A as j,B as k,D as G}from"./index-yuUUyctO.js";const $=(e,n,s,a)=>{var t,f,T,m;const o=[s,{code:n,...a||{}}];if((f=(t=e==null?void 0:e.services)==null?void 0:t.logger)!=null&&f.forward)return e.services.logger.forward(o,"warn","react-i18next::",!0);w(o[0])&&(o[0]=`react-i18next:: ${o[0]}`),(m=(T=e==null?void 0:e.services)==null?void 0:T.logger)!=null&&m.warn?e.services.logger.warn(...o):console!=null&&console.warn&&console.warn(...o)},L={},E=(e,n,s,a)=>{w(s)&&L[s]||(w(s)&&(L[s]=new Date),$(e,n,s,a))},P=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),n()};e.on("initialized",s)}},S=(e,n,s)=>{e.loadNamespaces(n,P(e,s))},O=(e,n,s,a)=>{if(w(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return S(e,s,a);s.forEach(o=>{e.options.ns.indexOf(o)<0&&e.options.ns.push(o)}),e.loadLanguages(n,P(e,a))},U=(e,n,s={})=>!n.languages||!n.languages.length?(E(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0):n.hasLoadedNamespace(e,{lng:s.lng,precheck:(a,o)=>{var t;if(((t=s.bindI18n)==null?void 0:t.indexOf("languageChanging"))>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!o(a.isLanguageChangingTo,e))return!1}}),w=e=>typeof e=="string",B=e=>typeof e=="object"&&e!==null,D=(e,n)=>{const s=g.useRef();return g.useEffect(()=>{s.current=e},[e,n]),s.current},F=(e,n,s,a)=>e.getFixedT(n,s,a),J=(e,n,s,a)=>g.useCallback(F(e,n,s,a),[e,n,s,a]),X=(e,n={})=>{var R,v,z,A;const{i18n:s}=n,{i18n:a,defaultNS:o}=g.useContext(_)||{},t=s||a||G();if(t&&!t.reportNamespaces&&(t.reportNamespaces=new j),!t){E(t,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const i=(l,u)=>w(u)?u:B(u)&&w(u.defaultValue)?u.defaultValue:Array.isArray(l)?l[l.length-1]:l,c=[i,{},!1];return c.t=i,c.i18n={},c.ready=!1,c}(R=t.options.react)!=null&&R.wait&&E(t,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const f={...k(),...t.options.react,...n},{useSuspense:T,keyPrefix:m}=f;let r=o||((v=t.options)==null?void 0:v.defaultNS);r=w(r)?[r]:r||["translation"],(A=(z=t.reportNamespaces).addUsedNamespaces)==null||A.call(z,r);const d=(t.isInitialized||t.initializedStoreOnce)&&r.every(i=>U(i,t,f)),M=J(t,n.lng||null,f.nsMode==="fallback"?r:r[0],m),C=()=>M,x=()=>F(t,n.lng||null,f.nsMode==="fallback"?r:r[0],m),[b,y]=g.useState(C);let h=r.join();n.lng&&(h=`${n.lng}${h}`);const I=D(h),N=g.useRef(!0);g.useEffect(()=>{const{bindI18n:i,bindI18nStore:c}=f;N.current=!0,!d&&!T&&(n.lng?O(t,n.lng,r,()=>{N.current&&y(x)}):S(t,r,()=>{N.current&&y(x)})),d&&I&&I!==h&&N.current&&y(x);const l=()=>{N.current&&y(x)};return i&&(t==null||t.on(i,l)),c&&(t==null||t.store.on(c,l)),()=>{N.current=!1,t&&(i==null||i.split(" ").forEach(u=>t.off(u,l))),c&&t&&c.split(" ").forEach(u=>t.store.off(u,l))}},[t,h]),g.useEffect(()=>{N.current&&d&&y(C)},[t,m,d]);const p=[b,t,d];if(p.t=b,p.i18n=t,p.ready=d,d||!d&&!T)return p;throw new Promise(i=>{n.lng?O(t,n.lng,r,()=>i()):S(t,r,()=>i())})};export{X as u};
